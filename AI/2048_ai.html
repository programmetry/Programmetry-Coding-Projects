<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048</title>
    <style>
        :root {
            --bg: #0e1117;
            --board: #171b23;
            --cell: #1f2430;
            --gap: 12px;
            --radius: 12px;
        }
        html, body {
            height: 100%;
            margin: 0;
        }
        body {
            background: var(--bg);
            color: #e8eefc;
            font-family: system-ui, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .wrap {
            width: min(520px, 94vw);
        }
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .title {
            font-weight: 800;
            font-size: 28px;
            letter-spacing: 0.3px;
        }
        .stats {
            display: flex;
            gap: 10px;
        }
        .pill {
            background: #151925;
            border-radius: 10px;
            padding: 8px 10px;
            text-align: center;
            min-width: 80px;
        }
        .pill span {
            font-size: 11px;
            opacity: 0.8;
            display: block;
        }
        .pill b {
            font-size: 18px;
        }
        .actions {
            display: flex;
            gap: 8px;
            margin: 8px 0 12px;
        }
        button {
            background: #1d2333;
            border: 1px solid #2a3350;
            color: #e8eefc;
            padding: 8px 12px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
        }
        button:hover {
            filter: brightness(1.08);
        }
        .board {
            position: relative;
            background: var(--board);
            border-radius: 16px;
            padding: 12px;
            box-shadow: inset 0 0 0 1px #222b46;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--gap);
        }
        .cell {
            background: var(--cell);
            border-radius: var(--radius);
            aspect-ratio: 1/1;
        }
        .layer {
            position: absolute;
            inset: 12px;
        }
        .tile {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius);
            font-weight: 800;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
            transition: transform 0.12s ease-in;
            user-select: none;
        }
        .n2 { background: #e6f0ff; color: #0b0d12; }
        .n4 { background: #cfe0ff; color: #0b0d12; }
        .n8 { background: #a9c7ff; color: #0b0d12; }
        .n16 { background: #84adff; color: #0b0d12; }
        .n32 { background: #5f93ff; color: #0b0d12; }
        .n64 { background: #3a78ff; color: #eaf1ff; }
        .n128 { background: #2d62d6; color: #eaf1ff; }
        .n256 { background: #244eac; color: #eaf1ff; }
        .n512 { background: #1b3b83; color: #eaf1ff; }
        .n1024 { background: #122859; color: #eaf1ff; }
        .n2048 { background: #f7b538; color: #0b0d12; }
        .hint {
            font-size: 12px;
            opacity: 0.75;
        }

        .overlay {
            position: absolute;
            inset: 12px;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(6, 8, 14, .78);
            backdrop-filter: blur(2px);
            border-radius: 16px;
        }
        .overlay.show {
            display: flex;
        }
        
        .dialog {
            background: #121624;
            border: 1px solid #2a3350;
            border-radius: 16px;
            padding: 18px;
            width: min(340px, 90%);
            text-align: center;
            box-shadow: 0 12px 30px rgba(0, 0, 0, .35);
        }
        .dialog h2 {
            margin: 2px 0 8px;
            font-size: 22px;
        }
        .dialog .scores {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 8px 0 14px;
        }
        .dialog .scores .pill {
            min-width: auto;
            padding: 10px 12px;
        }
        .dialog .scores .pill b {
            font-size: 20px;
        }
        .dialog .actions {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin: 0;
        }
        
    </style>
</head>
<body>
    <div class="wrap" role="application" aria-label="2048 game">
        <header>
            <div class="title">2048</div>
            <div class="stats">
                <div class="pill">
                    <span>SCORE</span>
                    <b id="score">0</b>
                </div>
                <div class="pill">
                    <span>BEST</span>
                    <b id="best">0</b>
                </div>
            </div>
        </header>
        <div class="actions">
            <button id="newBtn">New Game</button>
            <button id="aiToggle">AI: Off</button>
            <span class="hint">Use arrows or WASD</span>
        </div>
        <div class="board" id="board">
            <div class="grid" id="grid" aria-hidden="true"></div>
            <div class="layer" id="layer" aria-live="polite" aria-atomic="true"></div>
            <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-labelledby="goTitle">
                <div class="dialog">
                    <h2 id="goTitle">Game Over</h2>
                    <div class="scores">
                        <div class="pill">
                            <span>FINAL</span>
                            <b id="finalScore">0</b>
                        </div>
                        <div class="pill">
                            <span>BEST</span>
                            <b id="finalBest">0</b>
                        </div>
                    </div>
                    <div class="actions">
                        <button id="restartBtn">Restart</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        const size = 4;
        const gridEl = document.getElementById("grid");
        const layerEl = document.getElementById("layer");
        const scoreEl = document.getElementById("score");
        const bestEl = document.getElementById("best");
        const newBtn = document.getElementById("newBtn");
        const overlayEl = document.getElementById("overlay");
        const restartBtn = document.getElementById("restartBtn");
        const finalScoreEl = document.getElementById("finalScore");
        const finalBestEl = document.getElementById("finalBest");
        const aiToggle = document.getElementById("aiToggle");

        let tiles = [];
        let nextId = 1;
        let score = 0;
        let best = Number(localStorage.getItem("best-2048") || "0");
        let gameOver = false;
        let aiOn = false;
        let aiTimer = null;

        bestEl.textContent = String(best);

        function setupGrid() {
            gridEl.innerHTML = "";
            for (let i = 0; i < size * size; i++) {
                const c = document.createElement("div");
                c.className = "cell";
                gridEl.appendChild(c);
            }
        }

        function emptyCells() {
            const used = new Set(tiles.map(t => t.x + "-" + t.y));
            const cells = [];

            for (let x = 0; x < size; x++) {
                for (let y = 0; y < size; y++) {
                    if (!used.has(x + "-" + y)) {
                        cells.push({ x, y });
                    }
                }
            }

            return cells;
        }

        function addRandomTile() {
            const cells = emptyCells();
            
            if (!cells.length) {
                return;
            }

            const c = cells[Math.floor(Math.random() * cells.length)];
            const v = Math.random() < 0.9 ? 2 : 4;

            tiles.push({
                id: nextId++,
                value: v,
                x: c.x,
                y: c.y
            });
        }

        function cellToPixel(x, y) {
            const rect = layerEl.getBoundingClientRect();
            const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gap"));
            const tileSize = (rect.width - gap * (size - 1)) / size;
            const tx = x * (tileSize + gap);
            const ty = y * (tileSize + gap);
            return { tx, ty, tileSize };
        }

        function draw(instant = false) {
            const keep = new Set();

            for (const t of tiles) {
                let el = document.getElementById("tile-" + t.id);
                const isNew = !el;

                if (!el) {
                    el = document.createElement("div");
                    el.id = "tile-" + t.id;
                    el.className = "tile n" + t.value;
                    layerEl.appendChild(el);
                }
                if (!el.classList.contains("n" + t.value)) {
                    el.className = "tile n" + t.value;
                    el.textContent = "";
                }

                const p = cellToPixel(t.x, t.y);
                
                el.style.width = p.tileSize + "px";
                el.style.height = p.tileSize + "px";
                el.style.fontSize = (p.tileSize * 0.42) + "px";
                el.style.transform = "translate(" + p.tx + "px, " + p.ty + "px)";
                el.textContent = t.value;
                el.style.transition = (instant || isNew) ? "none" : "transform .12s ease-in";

                keep.add(el.id);
            }

            for (const child of Array.from(layerEl.children)) {
                if (!keep.has(child.id)) {
                    child.remove();
                }
            }

            scoreEl.textContent = score;

            if (score > best) {
                best = score;
                localStorage.setItem("best-2048", String(best));
                bestEl.textContent = String(best);
            }
        }

        function reset() {
            stopAI();
            tiles = [];
            nextId = 1;
            score = 0;
            gameOver = false;
            overlayEl.classList.remove("show");
            scoreEl.textContent = 0;
            layerEl.innerHTML = "";
            addRandomTile();
            addRandomTile();
            draw(true);
        }

        function movesAvailable() {
            if (emptyCells().length) {
                return true;
            }

            const at = (x, y) => tiles.find(t => t.x === x && t.y === y);

            for (const t of tiles) {
                const r = at(t.x + 1, t.y);
                const d = at(t.x, t.y + 1);
                if ((r && r.value === t.value) || (d && d.value === t.value)) {
                    return true;
                }
            }

            return false;
        }

        function showGameOver() {
            gameOver = true;
            finalScoreEl.textContent = String(score);
            finalBestEl.textContent = String(best);
            overlayEl.classList.add("show");
        }

        function move(dir) {
            if (gameOver) {
                return;
            }

            const vecs = [
                { x: -1, y: 0 },
                { x: 0, y: -1 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
            ];

            const v = vecs[dir];
            const xs = [...Array(size).keys()];
            const ys = [...Array(size).keys()];
            const tx = v.x > 0 ? xs.slice().reverse() : xs;
            const ty = v.y > 0 ? ys.slice().reverse() : ys;

            const at = (x, y) => tiles.find(t => t.x === x && t.y === y);
            let moved = false;

            for (const y of ty) {
                for (const x of tx) {
                    const t = at(x, y);

                    if (!t) {
                        continue;
                    }

                    let nx = x;
                    let ny = y;

                    while (true) {
                        const px = nx + v.x;
                        const py = ny + v.y;

                        if (px < 0 || py < 0 || px >= size || py >= size) {
                            break;
                        }

                        const o = at(px, py);

                        if (!o) {
                            nx = px;
                            ny = py;
                            continue;
                        }

                        if (o.value === t.value && !o.merged && !t.merged) {
                            nx = px;
                            ny = py;
                        }

                        break;
                    }

                    if (nx === x && ny === y) {
                        continue;
                    }

                    const target = at(nx, ny);

                    if (target && target.value === t.value && !target.merged && !t.merged) {
                        target.value *= 2;
                        target.merged = true;
                        tiles = tiles.filter(k => k.id !== t.id);
                        score += target.value;
                        moved = true;
                    } else {
                        t.x = nx;
                        t.y = ny;
                        moved = true;
                    }
                }
            }

            tiles.forEach(t => t.merged = false);

            if (moved) {
                addRandomTile();
                draw();

                if (!movesAvailable()) {
                    showGameOver();
                    stopAI();
                }
            }
        }

        function onKey(e) {
            const map = {
                ArrowLeft: 0, 
                ArrowUp: 1,
                ArrowRight: 2,
                ArrowDown: 3,
                a: 0,
                w: 1,
                d: 2,
                s: 3,
                A: 0,
                W: 1,
                D: 2,
                S: 3
            };

            const d = map[e.key];
            if (d === undefined) {
                return;
            }

            e.preventDefault();
            move(d);
        }

        let touchX = 0;
        let touchY = 0;

        const swipeMin = 24;

        function onTouchStart(e) {
            const t = e.changedTouches[0];
            touchX = t.clientX;
            touchY = t.clientY;
        }

        function onTouchEnd(e) {
            const t = e.changedTouches[0];
            const dx = t.clientX - touchX;
            const dy = t.clientY - touchY;

            if (Math.max(Math.abs(dx), Math.abs(dy)) < swipeMin) {
                return;
            }

            if (Math.abs(dx) > Math.abs(dy)) {
                move(dx > 0 ? 2 : 0);
            } else {
                move(dy > 0 ? 3 : 1);
            }
        }

        // AI Functionality

        // AI Helpers
        function tilesToMatrix(tiles) {
            const m = Array.from({
                length: size
            }, () => Array(size).fill(0));

            for (const t of tiles) {
                m[t.y][t.x] = t.value;
            }

            return m;
        }

        function matrixEmptyCells(m) {
            const cells = [];
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (m[y][x] === 0) {
                        cells.push({ x, y });
                    }
                }
            }
            return cells;
        }

        function cloneMatrix(m) {
            return m.map(r => r.slice());
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) {
                return false;
            }

            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }

            return true;
        }

        function slideAndMergeLine(line) {
            const f = line.filter(v => v !== 0);
            const out = [];

            for (let i = 0; i < f.length; i++) {
                if (i < f.length - 1 && f[i] === f[i + 1]) {
                    out.push(f[i] * 2);
                    i++;
                } else {
                    out.push(f[i]);
                }
            }

            while (out.length < size) {
                out.push(0);
            }

            return {
                line: out
            };
        }

        function simulateMoveMatrix(m, dir) {
            const after = cloneMatrix(m);
            let moved = false;
            
            if (dir === 0 || dir === 2) {
                for (let y = 0; y < size; y++) {
                    const row = after[y].slice();
                    const arr = (dir === 2) ? row.slice().reverse() : row;
                    const res = slideAndMergeLine(arr);
                    const newRow = (dir === 2) ? res.line.slice().reverse() : res.line;
                    if (!arraysEqual(row, newRow)) {
                        moved = true;
                    }
                    after[y] = newRow;
                }
            } else {
                for (let x = 0; x < size; x++) {
                    const col = [];
                    for (let y = 0; y < size; y++) {
                        col.push(after[y][x]);
                    }
                    const arr = (dir === 3) ? col.slice().reverse() : col;
                    const res = slideAndMergeLine(arr);
                    const newCol = (dir === 3) ? res.line.slice().reverse() : res.line;
                    for (let y = 0; y < size; y++) {
                        if (after[y][x] !== newCol[y]) {
                            moved = true;
                            after[y][x] = newCol[y];
                        }
                    }
                }
            }

            return {
                board: after,
                moved
            };
        }

        function placeTile(m, cell, value) {
            const c = cloneMatrix(m);
            c[cell.y][cell.x] = value;
            return c;
        }

        function isTerminalMatrix(m) {
            if (matrixEmptyCells(m).length > 0) {
                return false;
            }

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const v = m[y][x];
                    if (x + 1 < size && m[y][x + 1] === v) { 
                        return false;
                    }
                    if (y + 1 < size && m[y + 1][x] === v) { 
                        return false;
                    }
                }
            }

            return true;
        }

        // AI Heuristic
        const log2v = v => v ? Math.log2(v) : 0;

        function smoothness(m) {
            let penalty = 0;
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const v = m[y][x];

                    if (!v) {
                        continue;
                    }

                    const a = log2v(v);

                    if (x + 1 < size && m[y][x + 1]) {
                        penalty -= Math.abs(a - log2v(m[y][x + 1]));
                    }

                    if (y + 1 < size && m[y + 1][x]) {
                        penalty -= Math.abs(a - log2v(m[y + 1][x]));
                    }
                }
            }

            return penalty;
        }

        function monotonicity(m) {
            let score = 0;

            for (let y = 0; y < size; y++) {
                let inc = 0;
                let dec = 0;

                for (let x = 0; x < size - 1; x++) {
                    const a = log2v(m[y][x]);
                    const b = log2v(m[y][x + 1]);

                    if (a <= b) {
                        inc += b - a;
                    } else {
                        dec += a - b;
                    }
                }
                score += Math.max(inc, dec);
            }

            for (let x = 0; x < size; x++) {
                let inc = 0;
                let dec = 0;

                for (let y = 0; y < size - 1; y++) {
                    const a = log2v(m[y][x]);
                    const b = log2v(m[y + 1][x]);

                    if (a <= b) {
                        inc += b - a;
                    } else {
                        dec += a - b;
                    }
                }
                score += Math.max(inc, dec);
            }

            return score;
        }

        function maxInCorner(m) {
            let maxv = 0;
            let maxx = 0;
            let maxy = 0;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (m[y][x] > maxv) {
                        maxv = m[y][x];
                        maxx = x;
                        maxy = y;
                    }
                }
            }
            
            if ((maxx === 0 || maxx === size - 1) && (maxy === 0 || maxy === size - 1)) {
                return 1;
            } else {
                return 0;
            }
        }

        function mergePotential(m) {
            let pairs = 0;
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const v = m[y][x];
                    if (!v) {
                        continue;
                    }

                    if (x + 1 < size && m[y][x + 1] === v) {
                        pairs++;
                    }
                    if (y + 1 < size && m[y + 1][x] === v) {
                        pairs++;
                    }
                }
            }

            return pairs;
        }

        function heuristic(m) {
            const empty = matrixEmptyCells(m).length;
            const sm = smoothness(m);
            const mono = monotonicity(m);
            const corner = maxInCorner(m);
            const merges = mergePotential(m);

            return (
                1.0 * sm +
                1.8 * empty +
                2.5 * mono +
                3.0 * corner +
                0.1 * merges
            );
        }

        // AI Expectimax
        function expectimax(m, depth, isChance) {
            if (depth === 0 || isTerminalMatrix(m)) {
                return heuristic(m);
            }

            if (!isChance) {
                let best = -Infinity;
                let any = false;

                for (const dir of [0, 1, 2, 3]) {
                    const res = simulateMoveMatrix(m, dir);
                    
                    if (!res.moved) {
                        continue;
                    }

                    any = true;

                    const val = expectimax(res.board, depth - 1, true);

                    if (val > best) {
                        best = val;
                    }
                }

                return any ? best : heuristic(m);
            } else {
                const empties = matrixEmptyCells(m);

                if (!empties.length) {
                    return heuristic(m);
                }

                let total = 0;

                for (const cell of empties) {
                    const s2 = placeTile(m, cell, 2);
                    const s4 = placeTile(m, cell, 4);

                    total += 0.9 * expectimax(s2, depth - 1, false);
                    total += 0.1 * expectimax(s4, depth - 1, false);
                }

                return total / empties.length;
            }
        }

        function chooseBestMove(depth = 5) {
            const m = tilesToMatrix(tiles);
            let bestDir = null;
            let bestVal = -Infinity;

            for (const dir of [0, 1, 2, 3]) {
                const res = simulateMoveMatrix(m, dir);
                if (!res.moved) {
                    continue;
                }

                const val = expectimax(res.board, depth - 1, true);
                if (val > bestVal) {
                    bestVal = val;
                    bestDir = dir;
                }
            }

            return bestDir;
        }

        // AI Autoplay
        function startAI() {
            if (aiOn || gameOver) {
                return;
            }

            aiOn = true;
            aiToggle.textContent = "AI: On";
            aiTimer = setInterval(() => {
                if (gameOver) {
                    stopAI();
                    return;
                }

                const dir = chooseBestMove(5);
                if (dir == null) {
                    stopAI();
                    showGameOver();
                    return;
                }

                const before = JSON.stringify(tiles);

                move(dir);

                if (JSON.stringify(tiles) === before) {
                    stopAI();
                }
            }, 20);
        }

        function stopAI() {
            aiOn = false;
            aiToggle.textContent = "AI: Off";
            if (aiTimer) {
                clearInterval(aiTimer);
                aiTimer = null;
            }
        }

        function init() {
            setupGrid();
            reset();
            window.addEventListener("keydown", onKey);
            layerEl.addEventListener("touchstart", onTouchStart);
            layerEl.addEventListener("touchend", onTouchEnd);
            newBtn.addEventListener("click", reset);
            restartBtn.addEventListener("click", reset);
            aiToggle.addEventListener("click", () => {
                if (aiOn) {
                    stopAI();
                } else {
                    startAI();
                }
            })
            new ResizeObserver(() => draw(true)).observe(document.getElementById("board"));
        }

        init();
    </script>
</body>
</html>